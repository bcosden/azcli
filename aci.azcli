###############################################
# Azure Container Instances with Azure CLI
#
# References:
# https://azure.microsoft.com/de-de/resources/templates/201-aci-sftp-files/
# https://gist.github.com/bhummerstone/286300e7eca065cccdeaf853e5b98117
# (both by my admired colleague Ben Hummerstone!)
#
# Jose Moreno, October 2020
###############################################

# Variables
rg=acilab
location=westeurope
storage_account_name="$rg$RANDOM"
acr_name="$rg$RANDOM"
share_name=sftp
sftp_image=atmoz/sftp:latest
azcli_image=microsoft/azure-cli:latest
sftp_user=sftpuser

# If objects already exist
storage_account_name=$(az storage account list -g $rg --query '[0].name' -o tsv)
sql_server_name=$(az sql server list -g $rg --query '[0].name' -o tsv)
acr_name=$(az acr list -g $rg --query '[0].name' -o tsv)
identity_name=$(az identity list -g $rg --query '[0].name' -o tsv)
akv_name=$(az keyvault list -g $rg --query '[0].name' -o tsv)

# Create RG
az group create -n $rg -l $location

# Create storage account with Azure Files
az storage account create -n $storage_account_name -g $rg --sku Standard_LRS --kind StorageV2
storage_account_key=$(az storage account keys list --account-name $storage_account_name -g $rg --query '[0].value' -o tsv)
az storage share create --account-name $storage_account_name --account-key $storage_account_key --name $share_name

# Create share with private/public SSH keys
key_name=$rg
ssh-keygen -f $key_name -t rsa -N ''
az storage share create --account-name $storage_account_name --account-key $storage_account_key --name $sftp_user
az storage file upload --account-name $storage_account_name --account-key $storage_account_key -s $sftp_user --source ${key_name}
az storage file upload --account-name $storage_account_name --account-key $storage_account_key -s $sftp_user --source ${key_name}.pub

# Create ACR
az acr create -n $acr_name -g $rg -l $location --sku Standard --admin-enabled true
acr_user=$(az acr credential show -n $acr_name -g $rg --query username -o tsv)
acr_password=$(az acr credential show -n $acr_name -g $rg --query 'passwords[0].value' -o tsv)

########################
# Option 1: nginx+web  #
########################

# Certificates
openssl req -new -newkey rsa:2048 -nodes -keyout ssl.key -out ssl.csr -subj "/C=US/ST=WA/L=Redmond/O=AppDev/OU=IT/CN=nip.io"
openssl x509 -req -days 365 -in ssl.csr -signkey ssl.key -out ssl.crt

# Create nginx.conf for SSL
nginx_config_file=/tmp/nginx.conf
cat <<EOF > $nginx_config_file
user nginx;
worker_processes auto;
events {
  worker_connections 1024;
}
pid        /var/run/nginx.pid;
http {
    server {
        listen [::]:443 ssl;
        listen 443 ssl;
        server_name localhost;
        ssl_protocols              TLSv1.2;
        ssl_ciphers                ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:DHE-DSS-AES128-GCM-SHA256:kEDH+AESGCM:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA:ECDHE-ECDSA-AES256-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA:DHE-DSS-AES128-SHA256:DHE-RSA-AES256-SHA256:DHE-DSS-AES256-SHA:DHE-RSA-AES256-SHA:AES128-GCM-SHA256:AES256-GCM-SHA384:ECDHE-RSA-RC4-SHA:ECDHE-ECDSA-RC4-SHA:AES128:AES256:RC4-SHA:HIGH:!aNULL:!eNULL:!EXPORT:!DES:!3DES:!MD5:!PSK;
        ssl_prefer_server_ciphers  on;
        ssl_session_cache    shared:SSL:10m; # a 1mb cache can hold about 4000 sessions, so we can hold 40000 sessions
        ssl_session_timeout  24h;
        keepalive_timeout 300; # up from 75 secs default
        add_header Strict-Transport-Security 'max-age=31536000; includeSubDomains';
        ssl_certificate      /etc/nginx/ssl.crt;
        ssl_certificate_key  /etc/nginx/ssl.key;
        location / {
            proxy_pass http://localhost:80 ; # TODO: replace port if app listens on port other than 80
            proxy_set_header Connection "";
            proxy_set_header Host \$host;
            proxy_set_header X-Real-IP \$remote_addr;
            proxy_set_header X-Forwarded-For \$remote_addr;
        }
    }
}
EOF

# Encode to Base64
nginx_conf=$(cat $nginx_config_file | base64)
ssl_crt=$(cat ssl.crt | base64)
ssl_key=$(cat ssl.key | base64)

# Create YAML
aci_name=sslaci
aci_dns=${aci_name}${RANDOM}
aci_yaml_file=/tmp/sftp.yaml
cat <<EOF > $aci_yaml_file
api-version: 2019-12-01
location: westus
name: $aci_name
properties:
  containers:
  - name: nginx-with-ssl
    properties:
      image: nginx
      ports:
      - port: 443
        protocol: TCP
      resources:
        requests:
          cpu: 1.0
          memoryInGB: 1.5
      volumeMounts:
      - name: nginx-config
        mountPath: /etc/nginx
  - name: my-app
    properties:
      image: mcr.microsoft.com/azuredocs/aci-helloworld
      ports:
      - port: 80
        protocol: TCP
      resources:
        requests:
          cpu: 1.0
          memoryInGB: 1.5
  volumes:
  - secret:
      ssl.crt: "$ssl_crt"
      ssl.key: "$ssl_key"
      nginx.conf: "$nginx_conf"
    name: nginx-config
  ipAddress:
    ports:
    - port: 443
      protocol: TCP
    type: Public
    dnsNameLabel: $aci_dns
  osType: Linux
tags: null
type: Microsoft.ContainerInstance/containerGroups
EOF

# Deploy ACI
az container create -g $rg --file $aci_yaml_file

# Show
az container list -g $rg -o table
az container show -n $aci_name -g $rg --query ipAddress

# Logs
az container logs -n $aci_name -g $rg --container-name nginx-with-ssl

# Restart containers after image update
az container restart -n $aci_name -g $rg

# Cleanup
az container delete -n $aci_name -g $rg -y

########################
# Option 2: nginx+sftp #
########################

# Create nginx config file to use for creating an nginx image
folder_name=nginx_ftp
mkdir $folder_name
nginx_config_file=${folder_name}/nginx.conf
cat <<EOF > $nginx_config_file
user  nginx;
worker_processes  1;
error_log  /var/log/nginx/error.log warn;
pid        /var/run/nginx.pid;
events {
    worker_connections  1024;
}
http {
    include       /etc/nginx/mime.types;
    default_type  application/octet-stream;
    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
                      '$status $body_bytes_sent "$http_referer" '
                      '"$http_user_agent" "$http_x_forwarded_for"';
    access_log  /var/log/nginx/access.log  main;
    sendfile        on;
    keepalive_timeout  65;
    include /etc/nginx/conf.d/*.conf;
}
stream {
    server {
        listen 2222;
        proxy_pass localhost:22;
        allow 109.125.122.99;
        allow 10.240.0.0/16;
        deny all;
    }
}
EOF

# Create Dockerfile for nginx image
# Alternative: use nginx image and mount the config file: https://docs.microsoft.com/en-us/azure/container-instances/container-instances-container-group-ssl
# See this link to enable SSL as well
dockerfile=./${folder_name}/Dockerfile
cat <<EOF > $dockerfile
FROM nginx
COPY nginx.conf /etc/nginx/nginx.conf
EOF

# Build image
cd $folder_name
az acr build -r $acr_name -t $rg/nginx-sftp:1.0 $folder_name
az acr repository show-tags -n $acr_name --repository $rg/nginx-sftp -o table

# Container group YAML
aci_yaml_file=/tmp/sftp.yaml
cat <<EOF > $aci_yaml_file
apiVersion: 2019-12-01
name: sftp
properties:
  containers:
  - name: sftp
    properties:
      image: $sftp_image
      environmentVariables:
      - name: SFTP_USERS
        value: "${sftp_user}::1001"
      resources:
        requests:
          cpu: 1
          memoryInGb: 1
      ports:
      - port: 22
      volumeMounts:
      - mountPath: /home/${sftp_user}/upload
        name: sftpvolume
        readOnly: false
      - mountPath: /home/${sftp_user}/.ssh/keys
        name: sshkeyvolume
        readOnly: true
  - name: nginx-sidecar
    properties:
      image: $acr_name.azurecr.io/$rg/nginx-sftp:1.0
      resources:
        requests:
          cpu: 1
          memoryInGb: 1.5
      ports:
      - port: 2222
  osType: Linux
  ipAddress:
    type: Public
    ports:
    - protocol: tcp
      port: 2222
  imageRegistryCredentials:
  - server: ${acr_name}.azurecr.io
    username: "$acr_user"
    password: "$acr_password"
  volumes:
  - name: sftpvolume
    azureFile:
      readOnly: false
      shareName: $share_name
      storageAccountName: $storage_account_name
      storageAccountKey: $storage_account_key
  - name: sshkeyvolume
    azureFile:
      readOnly: false
      shareName: $sftp_user
      storageAccountName: $storage_account_name
      storageAccountKey: $storage_account_key
tags: {exampleTag: mslearn}
type: Microsoft.ContainerInstance/containerGroups
EOF

# Create ACI
az container create -g $rg --file $aci_yaml_file
az container list -g $rg -o table
az container show -n sftp -g $rg --query ipAddress

# Restart containers after image update
az container restart -n sftp -g $rg

# Cleanup
az container delete -n sftp -g $rg -y

#########################
# Option 3:API with SQL #
#########################

# See https://github.com/erjosito/whoami/blob/master/lab-guides/aci.md
# Can be combined with the SSL sidecar
# Additionally with managed identity


###############################
# Option 4: ssl+oauth sidecar #
###############################

# ToDo:
# - Redundancy with TM/AFD

# Variables
aci_name=sslaci
aci_dns=${aci_name}${RANDOM}
aci_fqdn=${aci_dns}.${location}.azurecontainer.io

# Certificates
openssl req -new -newkey rsa:2048 -nodes -keyout ssl.key -out ssl.csr -subj "/C=US/ST=WA/L=Redmond/O=AppDev/OU=IT/CN=${aci_dns}.${location}.azurecontainer.io"
openssl x509 -req -days 365 -in ssl.csr -signkey ssl.key -out ssl.crt

# Create nginx.conf for SSL
nginx_config_file=/tmp/nginx.conf
cat <<EOF > $nginx_config_file
user nginx;
worker_processes auto;
events {
  worker_connections 1024;
}
pid        /var/run/nginx.pid;
http {
    server {
        listen [::]:443 ssl;
        listen 443 ssl;
        server_name localhost;
        ssl_protocols              TLSv1.2;
        ssl_ciphers                ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:DHE-DSS-AES128-GCM-SHA256:kEDH+AESGCM:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA:ECDHE-ECDSA-AES256-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA:DHE-DSS-AES128-SHA256:DHE-RSA-AES256-SHA256:DHE-DSS-AES256-SHA:DHE-RSA-AES256-SHA:AES128-GCM-SHA256:AES256-GCM-SHA384:ECDHE-RSA-RC4-SHA:ECDHE-ECDSA-RC4-SHA:AES128:AES256:RC4-SHA:HIGH:!aNULL:!eNULL:!EXPORT:!DES:!3DES:!MD5:!PSK;
        ssl_prefer_server_ciphers  on;
        ssl_session_cache    shared:SSL:10m; # a 1mb cache can hold about 4000 sessions, so we can hold 40000 sessions
        ssl_session_timeout  24h;
        keepalive_timeout 300; # up from 75 secs default
        add_header Strict-Transport-Security 'max-age=31536000; includeSubDomains';
        ssl_certificate      /etc/nginx/ssl.crt;
        ssl_certificate_key  /etc/nginx/ssl.key;
        location / {
            proxy_pass http://127.0.0.1:4180 ;
            proxy_set_header Connection "";
            proxy_set_header Host \$host;
            proxy_set_header X-Real-IP \$remote_addr;
            proxy_set_header X-Real-IP \$remote_addr;
            proxy_set_header X-Forwarded-For \$remote_addr;
            proxy_buffer_size          128k;
            proxy_buffers              4 256k;
            proxy_busy_buffers_size    256k;
        }
    }
}
EOF

# Encode to Base64
nginx_conf=$(cat $nginx_config_file | base64)
ssl_crt=$(cat ssl.crt | base64)
ssl_key=$(cat ssl.key | base64)

# Create database
sql_server_name=sqlserver$RANDOM
sql_db_name=mydb
sql_username=azure
sql_password=Microsoft123!
az sql server create -n $sql_server_name -g $rg -l $location --admin-user $sql_username --admin-password $sql_password
sql_server_fqdn=$(az sql server show -n $sql_server_name -g $rg -o tsv --query fullyQualifiedDomainName)
az sql db create -n $sql_db_name -s $sql_server_name -g $rg -e Basic -c 5 --no-wait

# Create key vault
akv_name=akv$RANDOM
az keyvault create -n $akv_name -g $rg -l $location
az keyvault secret set -n sqlpassword --value $sql_password --vault-name $akv_name

# Create user identity
identity_name=myACIid
az identity create -n $identity_name -g $rg
identity_spid=$(az identity show -g $rg -n $identity_name --query principalId -o tsv)
identity_appid=$(az identity show -g $rg -n $identity_name --query clientId -o tsv)
identity_id=$(az identity show -g $rg -n $identity_name --query id -o tsv)
az keyvault set-policy -n $akv_name -g $rg --object-id $identity_spid --secret-permissions get
scope=$(az group show -n $rg --query id -o tsv)
az role assignment create --scope $scope --role Contributor --assignee $identity_appid

# Create script for init container
storage_account_key=$(az storage account keys list --account-name $storage_account_name -g $rg --query '[0].value' -o tsv)
az storage share create --account-name $storage_account_name --account-key $storage_account_key --name initscript
init_script_filename=init.sh
init_script_path=/tmp/
cat <<EOF > ${init_script_path}${init_script_filename}
echo "DEBUG: Environment variables:"
printenv
echo "Logging into Azure..."
az login --identity
echo "Getting secrets for Azure Key Vault \$AKV_NAME..."
az keyvault secret show --vault-name \$AKV_NAME -n sqlpassword --query 'value' -o tsv > /secrets/SQL_PASSWORD
echo "Getting my public IP addresss..."
myip=\$(curl -s4 ifconfig.co)
echo "Adding \$myip to firewall rules of SQL Server \$SQL_SERVER_NAME in RG \$RG..."
az sql server firewall-rule create -g \$RG -s \$SQL_SERVER_NAME -n \$RANDOM --start-ip-address \$myip --end-ip-address \$myip
EOF
az storage file upload --account-name $storage_account_name --account-key $storage_account_key -s initscript --source ${init_script_path}${init_script_filename}

# Create AAD app for authentication
aad_app_id=$(az ad app create --display-name "$aci_name" --identifier-uris "https://${aci_fqdn}" --query appId -o tsv)
ad_app_appid=$(az ad app show --id $aad_app_id --query appId -o tsv)
az ad app update --id $aad_app_id --reply-urls "https://${aci_fqdn}/oauth2/callback"
az ad sp create --id $aad_app_id
ad_app_secret=$(az ad sp credential reset --name $aad_app_id --credential-description "aci test" --query password -o tsv)
az ad app permission add \
    --id $aad_app_id \
    --api 00000003-0000-0000-c000-000000000000 \
    --api-permissions e1fe6dd8-ba31-4d61-89e7-88639da4683d=Scope 37f7f235-527c-4136-accd-4a02d197296e=Scope
az ad app permission grant --id $aad_app_id --api 00000003-0000-0000-c000-000000000000
az ad app permission admin-consent --id  $aad_app_id

# Create YAML
aci_yaml_file=/tmp/sqlapi.yaml
cat <<EOF > $aci_yaml_file
apiVersion: 2019-12-01
location: westus
name: $aci_name
identity:
  type: UserAssigned
  userAssignedIdentities:
    $identity_id: {}
properties:
  initContainers:
  - name: azcli
    properties:
      image: microsoft/azure-cli:latest
      command:
      # - "az login --identity && az keyvault secret show --vault-name $akv_name -n sqlpassword --query 'value' -o tsv > /secrets/SQL_PASSWORD"
      # - "touch"
      # - "/secrets/helloworld.txt"
      - "/bin/sh"
      - "-c"
      - "/mnt/init/$init_script_filename"
      environmentVariables:
      - name: RG
        value: $rg
      - name: AKV_NAME
        value: $akv_name
      - name: SQL_SERVER_NAME
        value: $sql_server_name
      volumeMounts:
      - name: secrets
        mountPath: /secrets
      - name: initscript
        mountPath: /mnt/init/
  containers:
  - name: nginx
    properties:
      image: nginx
      ports:
      - port: 443
        protocol: TCP
      resources:
        requests:
          cpu: 1.0
          memoryInGB: 1
      volumeMounts:
      - name: nginx-config
        mountPath: /etc/nginx
  - name: oauth
    properties:
      image: quay.io/oauth2-proxy/oauth2-proxy:latest
      environmentVariables:
      - name: OAUTH2_PROXY_EMAIL_DOMAINS
        value: "*"
      - name: OAUTH2_PROXY_REVERSE_PROXY
        value: true
      - name: OAUTH2_PROXY_COOKIE_SECRET
        secureValue: ffdsfwerewrwe173
      - name: OAUTH2_PROXY_UPSTREAMS
        value: http://127.0.0.1:80/
      - name: OAUTH2_PROXY_PASS_HOST_HEADER
        value: false
      - name: OAUTH2_PROXY_PASS_AUTHORIZATION_HEADER
        value: true
      - name: OAUTH2_PROXY_PROVIDER
        value: azure
      - name: OAUTH2_PROXY_CLIENT_ID
        value: $ad_app_appid
      - name: OAUTH2_PROXY_CLIENT_SECRET
        secureValue: $ad_app_secret
      ports:
      - port: 4180
        protocol: TCP
      resources:
        requests:
          cpu: 1.0
          memoryInGB: 1
  - name: web
    properties:
      image: erjosito/web:1.0
      environmentVariables:
      - name: API_URL
        value: 127.0.0.1:8080
      ports:
      - port: 80
        protocol: TCP
      resources:
        requests:
          cpu: 0.5
          memoryInGB: 0.5
  - name: sqlapi
    properties:
      image: erjosito/sqlapi:1.0
      environmentVariables:
      - name: SQL_SERVER_USERNAME
        value: $sql_username
      - name: SQL_SERVER_PASSWORD
        secureValue: $sql_password
      - name: SQL_SERVER_FQDN
        value: $sql_server_fqdn
      ports:
      - port: 8080
        protocol: TCP
      resources:
        requests:
          cpu: 0.5
          memoryInGB: 0.5
      volumeMounts:
      - name: secrets
        mountPath: /secrets/
  volumes:
  - name: nginx-config
    secret:
      ssl.crt: "$ssl_crt"
      ssl.key: "$ssl_key"
      nginx.conf: "$nginx_conf"
  - name: secrets
    emptyDir: {}
  - name: initscript
    azureFile:
      readOnly: false
      shareName: initscript
      storageAccountName: $storage_account_name
      storageAccountKey: $storage_account_key
  ipAddress:
    ports:
    - port: 443
      protocol: TCP
    type: Public
    dnsNameLabel: $aci_dns
  osType: Linux
tags: null
type: Microsoft.ContainerInstance/containerGroups
EOF

# Verify created YAML
# more $aci_yaml_file

# Deploy ACI
az container create -g $rg --file $aci_yaml_file

# Add public IP to SQL Server Firewall
aci_source_ip=40.91.206.16  # Take this from the GUI
az sql server firewall-rule create -g $rg -s $sql_server_name -n public_sqlapi_aci-source --start-ip-address $aci_source_ip --end-ip-address $aci_source_ip

# Show
az container list -g $rg -o table
az container show -n $aci_name -g $rg --query ipAddress
az container show -n $aci_name -g $rg --query instanceView.events -o table

# Logs
az container logs -n $aci_name -g $rg --container-name azcli
az container logs -n $aci_name -g $rg --container-name nginx
az container logs -n $aci_name -g $rg --container-name oauth
az container logs -n $aci_name -g $rg --container-name web
az container logs -n $aci_name -g $rg --container-name sqlapi

# Verify Azure SQL Server rules
az sql server firewall-rule list -s $sql_server_name -g $rg -o table

# Exec
az container exec -n $aci_name -g $rg --container-name oauth --exec-command /bin/sh
az container exec -n $aci_name -g $rg --container-name azcli --exec-command /bin/sh
az container exec -n $aci_name -g $rg --container-name sqlapi --exec-command /bin/sh
az container exec -n $aci_name -g $rg --container-name sqlapi --exec-command "cat /secrets/SQL_PASSWORD"

# Restart containers, for example after image update
az container restart -n $aci_name -g $rg

# Cleanup
az container delete -n $aci_name -g $rg -y

# Danger Zone!
# az group delete -n $rg -y --no-wait